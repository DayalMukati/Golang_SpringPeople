================================================================================
                CHAPTER 8: LOOSE COUPLING - TEST RESULTS
================================================================================
Test Execution Date: October 1, 2025, 11:15 IST
Go Version: 1.25.1
Platform: macOS (darwin/arm64)
Test Status: COMPLETED ‚úì

PURPOSE OF THIS DOCUMENT:
This file contains comprehensive analysis of loose coupling principles and
patterns for microservices demonstrated in Chapter 8. Topics covered:
  - Tight vs Loose coupling comparison
  - API contracts and versioning
  - Asynchronous communication
  - Event-driven architecture
  - Service discovery
  - Dependency inversion
  - Design for change

TEST RESULT FORMAT:
  üìÅ File Location
  üìù Concept Description & Problem It Solves
  üèóÔ∏è  How It Works
  ‚úÖ Expected Behavior
  üîß Compilation Status
  üí° Key Takeaways

================================================================================
SECTION 01: INTRODUCTION - TIGHT VS LOOSE COUPLING
================================================================================
Topic: Understanding coupling and its impact on maintainability
Learning Goal: Recognize tight coupling and learn to avoid it

--------------------------------------------------------------------------------
TEST 1.1: Tight Coupling Example (Anti-Pattern)
--------------------------------------------------------------------------------
üìÅ Location: chapter8-loose-coupling/01-introduction/tight_coupling.go

üìù Problem It Solves (Actually: Problems It Creates!):
   Tightly coupled code looks simple but creates major problems:
   - ProcessPayment directly calls fraudCheck() and sendNotification()
   - Can't test ProcessPayment without these functions
   - Can't replace fraud logic without changing ProcessPayment
   - Can't make fraud check asynchronous
   - Can't add new notification channels
   - Functions are "glued together"

üèóÔ∏è  Anti-Pattern Code:
   ```go
   func ProcessPayment(amount int) {
       fraudCheck(amount)      // Direct dependency
       sendNotification()      // Direct dependency
   }

   func fraudCheck(amount int) {
       // fraud logic here
   }

   func sendNotification() {
       // notification logic here
   }
   ```

   Problems Illustrated:
   1. Direct Function Calls:
      - ProcessPayment KNOWS about fraudCheck implementation
      - Can't swap fraud provider without code changes

   2. No Abstraction:
      - No interfaces between components
      - Changes ripple through system

   3. Hard to Test:
      ```go
      // Can't test ProcessPayment without real fraud check
      func TestProcessPayment(t *testing.T) {
           ProcessPayment(100)  // Also runs fraudCheck!
           // How to verify payment logic separately?
       }
       ```

   4. Hard to Change:
      ```go
      // Want to add email notification?
      // Must modify ProcessPayment!
      func ProcessPayment(amount int) {
           fraudCheck(amount)
           sendNotification()
           sendEmailNotification()  // NEW: Modified existing function
       }
       ```

‚úÖ Expected Behavior:
   - Compiles and runs
   - Processes payment with fraud check and notification
   - But: NOT maintainable or testable

üîß Compilation Status: SUCCESS ‚úì
   Command: go build tight_coupling.go
   Result: Binary created successfully

üí° Why This Is Bad:
   - Change one thing, break multiple things
   - Can't test components independently
   - Can't swap implementations
   - Hard to understand dependencies
   - Violates Open/Closed Principle
   - NOT suitable for microservices

--------------------------------------------------------------------------------
TEST 1.2: Loose Coupling Example (Best Practice)
--------------------------------------------------------------------------------
üìÅ Location: chapter8-loose-coupling/01-introduction/loose_coupling.go

üìù Problem It Solves:
   Loose coupling makes code:
   - Testable (mock dependencies)
   - Flexible (swap implementations)
   - Maintainable (change one thing)
   - Understandable (clear contracts)
   - Extensible (add new features easily)

üèóÔ∏è  How It Works (Dependency Injection + Interfaces):
   ```go
   // Define interfaces (contracts)
   type FraudChecker interface {
       Check(amount int) bool
   }

   type Notifier interface {
       Send(message string)
   }

   // Function depends on interfaces, not concrete types
   func ProcessPayment(amount int, fc FraudChecker, n Notifier) {
       if fc.Check(amount) {  // Uses interface
           n.Send("Payment processed successfully")  // Uses interface
       }
   }

   // Concrete implementations
   type SimpleFraudChecker struct{}

   func (s SimpleFraudChecker) Check(amount int) bool {
       return amount < 100000  // Business logic
   }

   type SimpleNotifier struct{}

   func (s SimpleNotifier) Send(message string) {
       fmt.Println("Notification:", message)
   }

   // Usage: Inject dependencies
   func main() {
       fc := SimpleFraudChecker{}
       n := SimpleNotifier{}
       ProcessPayment(5000, fc, n)  // Dependencies injected
   }
   ```

   Benefits of This Design:

   1. Easy Testing (Mock Dependencies):
   ```go
   type MockFraudChecker struct {
       shouldApprove bool
   }

   func (m MockFraudChecker) Check(amount int) bool {
       return m.shouldApprove  // Controlled behavior
   }

   func TestProcessPayment(t *testing.T) {
       mock := MockFraudChecker{shouldApprove: true}
       mockNotifier := MockNotifier{}
       ProcessPayment(100, mock, mockNotifier)
       // Verify payment logic WITHOUT real fraud check!
   }
   ```

   2. Easy to Swap Implementations:
   ```go
   // Option 1: Simple fraud check
   fc := SimpleFraudChecker{}

   // Option 2: ML-based fraud check
   fc := MLFraudChecker{modelPath: "fraud_model.pb"}

   // Option 3: External API fraud check
   fc := ExternalFraudChecker{apiURL: "https://fraud-api.com"}

   // ProcessPayment doesn't need to change!
   ProcessPayment(5000, fc, n)
   ```

   3. Easy to Add Features:
   ```go
   // Want multiple notification channels?
   type MultiNotifier struct {
       notifiers []Notifier
   }

   func (m MultiNotifier) Send(message string) {
       for _, n := range m.notifiers {
           n.Send(message)  // Send to all channels
       }
   }

   multi := MultiNotifier{
       notifiers: []Notifier{
           EmailNotifier{},
           SMSNotifier{},
           PushNotifier{},
       },
   }
   ProcessPayment(5000, fc, multi)  // No changes to ProcessPayment!
   ```

‚úÖ Expected Behavior:
   Run:
   ```bash
   go run loose_coupling.go
   ```
   Output:
   ```
   Notification: Payment processed successfully
   ```

üîß Compilation Status: SUCCESS ‚úì
   Command: go build loose_coupling.go
   Result: Binary created successfully

üí° Key Principles:
   1. Depend on Abstractions (Interfaces), Not Concretions
      - ProcessPayment depends on FraudChecker interface
      - NOT on SimpleFraudChecker concrete type

   2. Dependency Injection
      - Dependencies passed in, not created inside
      - Caller controls what implementations to use

   3. Single Responsibility
      - ProcessPayment: payment logic only
      - FraudChecker: fraud logic only
      - Notifier: notification logic only

   4. Open/Closed Principle
      - Open for extension (add new implementations)
      - Closed for modification (ProcessPayment unchanged)

================================================================================
SECTION 03: API CONTRACTS
================================================================================
Topic: Defining clear interfaces between services
Learning Goal: API versioning and backward compatibility

üìÅ Location: chapter8-loose-coupling/03-api-contracts/payment_api.go

üìù Problem It Solves:
   APIs change over time:
   - Add new fields to requests
   - Change response format
   - Deprecate old endpoints
   - But: Can't break existing clients!

   API Contract Solution:
   - Versioned APIs (v1, v2, v3)
   - Backward compatibility
   - Clear documentation
   - Deprecation strategy

üèóÔ∏è  API Versioning Strategies:

   1. URL Path Versioning:
   ```go
   // v1 API
   http.HandleFunc("/api/v1/pay", payV1Handler)

   // v2 API (new fields, different behavior)
   http.HandleFunc("/api/v2/pay", payV2Handler)

   // Clients choose version:
   // Old clients: POST /api/v1/pay
   // New clients: POST /api/v2/pay
   ```

   2. Header Versioning:
   ```go
   func payHandler(w http.ResponseWriter, r *http.Request) {
       version := r.Header.Get("API-Version")
       switch version {
       case "v1":
           handleV1(w, r)
       case "v2":
           handleV2(w, r)
       default:
           handleLatest(w, r)
       }
   }
   ```

   3. Content Negotiation:
   ```go
   Accept: application/vnd.finpay.v1+json
   Accept: application/vnd.finpay.v2+json
   ```

   Backward Compatibility Rules:
   ‚úì CAN add optional fields
   ‚úì CAN add new endpoints
   ‚úì CAN deprecate old endpoints (with warning period)
   ‚úó CANNOT remove fields
   ‚úó CANNOT change field types
   ‚úó CANNOT change field semantics

üí° Key Takeaways:
   - Always version APIs from day 1
   - Support multiple versions simultaneously
   - Give 6-12 months before deprecating old versions
   - Document breaking changes clearly
   - Use API gateway for version routing

================================================================================
SECTION 04: ASYNCHRONOUS COMMUNICATION
================================================================================
Topic: Decoupling through message queues
Learning Goal: Event-driven patterns for loose coupling

üìÅ Location: chapter8-loose-coupling/04-async-communication/queue_demo.go

üìù Problem It Solves:
   Synchronous communication problems:
   - Payment waits for notification service (slow)
   - If notification service down, payment fails
   - Tight coupling via HTTP calls
   - Can't handle bursts (notification service overwhelmed)

   Async Communication Solution:
   - Payment publishes to queue
   - Returns immediately (fast)
   - Notification service consumes at own pace
   - If notification service down, messages queued
   - Natural load leveling

üèóÔ∏è  How Message Queues Work:
   ```
   Payment Service:
   1. Process payment
   2. Publish to queue: {"event":"PaymentComplete","amount":100}
   3. Return success to client (DON'T WAIT)

   Message Queue:
   - Stores messages durably
   - Delivers to consumers
   - Retries on failure

   Notification Service:
   - Consumes messages at own pace
   - Sends notifications
   - Acknowledges completion
   ```

   Code Pattern:
   ```go
   // Producer (Payment Service)
   func processPayment(amount int) {
       // 1. Business logic
       payment := createPayment(amount)

       // 2. Publish event (non-blocking)
       queue.Publish("payment.completed", payment)

       // 3. Return immediately
       return  // Don't wait for notification!
   }

   // Consumer (Notification Service)
   func main() {
       queue.Subscribe("payment.completed", func(msg Message) {
           // Process at own pace
           sendEmail(msg.UserEmail)
           sendSMS(msg.UserPhone)
           sendPush(msg.DeviceID)
       })
   }
   ```

üí° Benefits:
   - Services don't wait for each other (fast)
   - Services can be down temporarily (resilient)
   - Natural load leveling (consumer's pace)
   - Easy to add new consumers (extensible)
   - Temporal decoupling (don't need to be online simultaneously)

================================================================================
SECTION 05: EVENT-DRIVEN ARCHITECTURE
================================================================================
Topic: Publish-subscribe pattern for loose coupling
Learning Goal: Event-driven microservices communication

--------------------------------------------------------------------------------
TEST 5.1: Event-Driven Demo with Channels
--------------------------------------------------------------------------------
üìÅ Location: chapter8-loose-coupling/05-event-driven/event_demo.go

üìù Problem It Solves:
   Multiple services interested in payment events:
   - Notification service
   - Analytics service
   - Fraud detection service
   - Accounting service

   Without events:
   - Payment calls each service (tight coupling)
   - Payment needs to know all consumers
   - Adding new consumer requires changing payment

   With events:
   - Payment publishes event (doesn't know consumers)
   - Services subscribe to events they care about
   - Adding new consumer requires NO changes to payment

üèóÔ∏è  How It Works:
   ```go
   type Event struct {
       Name string  // Event type (e.g., "TransactionCreated")
       Data string  // Event payload (e.g., "TXN123")
   }

   // Publisher: Payment Service
   func payment(events chan Event) {
       fmt.Println("Payment: publishing TransactionCreated")
       events <- Event{
           Name: "TransactionCreated",
           Data: "TXN123",
       }
       // Payment doesn't know who's listening!
   }

   // Subscriber: Fraud Service
   func fraud(events chan Event) {
       for e := range events {
           if e.Name == "TransactionCreated" {
               fmt.Println("Fraud: checking transaction", e.Data)
               // Process event...
           }
       }
   }

   // Subscriber: Analytics Service
   func analytics(events chan Event) {
       for e := range events {
           if e.Name == "TransactionCreated" {
               fmt.Println("Analytics: recording transaction", e.Data)
               // Process event...
           }
       }
   }

   func main() {
       events := make(chan Event, 10)  // Event bus

       go fraud(events)       // Subscriber 1
       go analytics(events)   // Subscriber 2
       // Easy to add more subscribers!

       payment(events)        // Publisher

       select {}  // Keep running
   }
   ```

   Event Flow:
   ```
   Payment Service:
       ‚Üì publishes
   TransactionCreated Event
       ‚Üì ‚Üì ‚Üì (broadcast)
   Fraud    Analytics    Notification    Accounting
   (All receive same event independently)
   ```

‚úÖ Expected Behavior:
   Run:
   ```bash
   go run event_demo.go
   ```
   Output:
   ```
   Payment: publishing TransactionCreated
   Fraud: checking transaction TXN123
   ```

üîß Compilation Status: SUCCESS ‚úì

üí° Event-Driven Benefits:
   1. Loose Coupling:
      - Publisher doesn't know subscribers
      - Subscribers don't know each other
      - Easy to add/remove subscribers

   2. Scalability:
      - Multiple instances of each subscriber
      - Process events in parallel
      - Natural load distribution

   3. Resilience:
      - If subscriber down, events queued
      - Subscriber catches up when back online
      - No data loss

   4. Extensibility:
      - New requirements? Add new subscriber
      - No changes to existing services
      - Open/Closed Principle

   Production Event Brokers:
   - Kafka: High throughput, durable, replayable
   - RabbitMQ: Feature-rich, flexible routing
   - NATS: Lightweight, fast, simple
   - AWS SNS/SQS: Managed, serverless
   - Google Pub/Sub: Managed, serverless

================================================================================
SECTION 06: SERVICE DISCOVERY
================================================================================
Topic: Dynamic service location for loose coupling
Learning Goal: Decouple services from physical locations

üìÅ Location: chapter8-loose-coupling/06-service-discovery/discovery_demo.go

üìù Problem It Solves:
   Hard-coded service URLs:
   ```go
   resp, _ := http.Get("http://fraud-service-1.example.com:8080/check")
   // Problems:
   // - What if fraud-service-1 goes down?
   // - What if we add fraud-service-2?
   // - What if IP changes?
   // - What if we move to different cloud?
   ```

   Service Discovery Solution:
   ```go
   resp, _ := http.Get("http://fraud-service/check")
   // Benefits:
   // - fraud-service resolves to healthy instance
   // - Automatic load balancing
   // - Automatic failover
   // - No hard-coded IPs
   ```

üèóÔ∏è  Service Discovery Patterns:

   1. Client-Side Discovery (Consul, Eureka):
   ```
   Client ‚Üí Service Registry (get healthy instances)
   Service Registry ‚Üí Returns: [fraud-1:8080, fraud-2:8081]
   Client ‚Üí Load balance ‚Üí Call fraud-2:8081
   ```

   2. Server-Side Discovery (Kubernetes, AWS ELB):
   ```
   Client ‚Üí Load Balancer (fraud-service)
   Load Balancer ‚Üí Queries registry
   Load Balancer ‚Üí Forwards to fraud-2:8081
   Client doesn't know about registry
   ```

   3. Kubernetes DNS (Recommended):
   ```go
   // Service registration: automatic (K8s creates it)
   // Service discovery: automatic (K8s DNS)
   resp, _ := http.Get("http://fraud-service:8080/check")
   // fraud-service resolves to Service ClusterIP
   // Service load balances to healthy pods
   // Zero configuration!
   ```

üí° Key Takeaways:
   - Never hard-code service URLs
   - Use service names, not IPs
   - Kubernetes provides built-in service discovery
   - Services register automatically on startup
   - Health checks ensure traffic to healthy instances

================================================================================
SECTION 07: DEPENDENCY INVERSION
================================================================================
Topic: High-level modules independent of low-level modules
Learning Goal: Depend on abstractions, not implementations

üìÅ Location: chapter8-loose-coupling/07-dependency-inversion/interface_demo.go

üìù Problem It Solves:
   Traditional dependency flow:
   ```
   PaymentService (high-level)
       ‚Üì depends on
   DatabaseClient (low-level)

   Problem: Can't test PaymentService without real database
   ```

   Dependency Inversion:
   ```
   PaymentService (high-level)
       ‚Üì depends on
   Repository Interface (abstraction)
       ‚Üë implemented by
   DatabaseClient (low-level)

   Benefit: PaymentService depends on interface
   Can use MockRepository for testing!
   ```

üèóÔ∏è  How It Works:
   ```go
   // High-level module defines interface it needs
   type PaymentRepository interface {
       Save(payment Payment) error
       Find(id string) (Payment, error)
   }

   // High-level module depends on interface
   type PaymentService struct {
       repo PaymentRepository  // Interface, not concrete type
   }

   func (s *PaymentService) ProcessPayment(amount int) error {
       payment := Payment{Amount: amount}
       return s.repo.Save(payment)  // Calls interface method
   }

   // Low-level module implements interface
   type PostgresRepository struct {
       db *sql.DB
   }

   func (r *PostgresRepository) Save(p Payment) error {
       _, err := r.db.Exec("INSERT INTO payments ...")
       return err
   }

   // Production: Use real database
   db := connectPostgres()
   repo := &PostgresRepository{db: db}
   service := &PaymentService{repo: repo}

   // Testing: Use mock
   mock := &MockRepository{/* controlled behavior */}
   service := &PaymentService{repo: mock}
   ```

üí° Benefits:
   - Testability (use mocks)
   - Flexibility (swap implementations)
   - Maintainability (change low-level without affecting high-level)
   - Follows SOLID principles

================================================================================
SECTION 08: DESIGN FOR CHANGE
================================================================================
Topic: Building systems that adapt to changing requirements
Learning Goal: Anticipate change and design accordingly

üìÅ Location: chapter8-loose-coupling/08-design-for-change/extensible_channels.go

üìù Problem It Solves:
   Requirements always change:
   - Today: Email notifications
   - Tomorrow: Add SMS
   - Next week: Add push notifications
   - Next month: Add Slack notifications

   Design for change:
   - Use interfaces (add new implementations)
   - Use event-driven (add new subscribers)
   - Use configuration (change without code changes)
   - Use feature flags (enable/disable features)

üèóÔ∏è  Extensible Design Pattern:
   ```go
   // Interface allows adding channels
   type NotificationChannel interface {
       Send(user User, message string) error
   }

   // Easy to add new channels
   type EmailChannel struct{}
   func (e EmailChannel) Send(user User, message string) error {
       return sendEmail(user.Email, message)
   }

   type SMSChannel struct{}
   func (s SMSChannel) Send(user User, message string) error {
       return sendSMS(user.Phone, message)
   }

   // Notification service uses list of channels
   type NotificationService struct {
       channels []NotificationChannel
   }

   func (n *NotificationService) Notify(user User, message string) {
       for _, channel := range n.channels {
           channel.Send(user, message)  // Send via all channels
       }
   }

   // Configuration-driven channel selection
   func main() {
       channels := []NotificationChannel{}

       if config.Get("email.enabled") {
           channels = append(channels, EmailChannel{})
       }
       if config.Get("sms.enabled") {
           channels = append(channels, SMSChannel{})
       }
       if config.Get("push.enabled") {
           channels = append(channels, PushChannel{})
       }

       service := NotificationService{channels: channels}
   }
   ```

üí° Design for Change Principles:
   1. Use Interfaces (plugin architecture)
   2. Use Configuration (change without deploy)
   3. Use Feature Flags (gradual rollout)
   4. Use Event-Driven (add consumers easily)
   5. Use Dependency Injection (swap implementations)

================================================================================
                            CHAPTER 8 SUMMARY
================================================================================

Total Sections Analyzed: 10 sections
Total Code Examples: 8 files
Compilation Success Rate: 100%

SECTIONS COVERED:
‚úì 01-introduction (Tight vs Loose coupling)
‚úì 02-benefits (Concepts)
‚úì 03-api-contracts (Versioning patterns)
‚úì 04-async-communication (Message queues)
‚úì 05-event-driven (Pub-sub with channels)
‚úì 06-service-discovery (DNS-based discovery)
‚úì 07-dependency-inversion (Interfaces)
‚úì 08-design-for-change (Extensibility)
‚úì 09-trade-offs (Concepts)
‚úì 10-summary-best-practices (Concepts)

OVERALL STATUS: ALL CODE COMPILED SUCCESSFULLY ‚úì

KEY LEARNINGS FROM CHAPTER 8:

1. Loose Coupling Techniques:
   - Interfaces (depend on abstractions)
   - Dependency Injection (pass dependencies)
   - Asynchronous Communication (message queues)
   - Event-Driven Architecture (pub-sub)
   - Service Discovery (no hard-coded URLs)

2. Benefits of Loose Coupling:
   - Independent Development (teams work in parallel)
   - Independent Deployment (deploy services separately)
   - Independent Scaling (scale services independently)
   - Easy Testing (mock dependencies)
   - Resilience (failures isolated)

3. Trade-Offs:
   - Complexity: More moving parts
   - Debugging: Distributed tracing needed
   - Consistency: Eventual consistency patterns
   - Latency: Network calls add overhead
   - Learning Curve: New patterns to learn

BEST PRACTICES FOR FINPAY:

1. Service Communication:
   ‚úì Synchronous: Use for user-facing requests
   ‚úì Asynchronous: Use for background tasks
   ‚úì Events: Use for notifying multiple services
   ‚úì Always use timeouts
   ‚úì Always handle errors

2. API Design:
   ‚úì Version from day 1 (/api/v1/...)
   ‚úì Backward compatibility always
   ‚úì Deprecation period (6-12 months)
   ‚úì Clear documentation
   ‚úì Changelog for every change

3. Dependency Management:
   ‚úì Use interfaces
   ‚úì Inject dependencies
   ‚úì Mock for testing
   ‚úì No circular dependencies
   ‚úì Minimize dependencies

4. Event-Driven:
   ‚úì Use for loose coupling
   ‚úì Kafka/RabbitMQ for production
   ‚úì Event schema registry
   ‚úì Event versioning
   ‚úì Idempotent consumers

LOOSE COUPLING PATTERNS SUMMARY:

1. Interface-Based Coupling:
   ```go
   // Define interface
   type FraudChecker interface {
       Check(amount int) bool
   }

   // Depend on interface
   func ProcessPayment(fc FraudChecker) {
       if fc.Check(amount) {
           // ...
       }
   }
   ```

2. Event-Based Coupling:
   ```go
   // Publish event
   events.Publish("payment.completed", payment)

   // Subscribe to event
   events.Subscribe("payment.completed", handler)
   ```

3. Message Queue Coupling:
   ```go
   // Producer
   queue.Send("payment-queue", message)

   // Consumer
   queue.Receive("payment-queue", handler)
   ```

4. Service Discovery:
   ```go
   // No hard-coded URLs
   http.Get("http://fraud-service/check")
   // fraud-service resolved via DNS/registry
   ```

ANTI-PATTERNS TO AVOID:

1. Distributed Monolith:
   ‚úó Services share database
   ‚úó Services know each other's internals
   ‚úó Changes require coordinated deployment
   ‚úì Each service owns its data
   ‚úì Communicate via APIs/events only

2. Chatty Services:
   ‚úó PaymentService ‚Üí 50 calls to UserService per payment
   ‚úì Batch requests
   ‚úì Cache frequently accessed data
   ‚úì Use async events for non-critical data

3. Over-Engineering:
   ‚úó Event-driven for everything (including critical path)
   ‚úó Too many small services
   ‚úó Premature optimization
   ‚úì Synchronous for critical user-facing operations
   ‚úì Asynchronous for background tasks
   ‚úì Start simple, add complexity when needed

FINPAY ARCHITECTURE WITH LOOSE COUPLING:

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Client    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ HTTP (sync)
       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        Events (async)        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Payment   ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ Notification‚îÇ
‚îÇ   Service   ‚îÇ                                 ‚îÇ   Service   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îò                                 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
      ‚îÇ   ‚îÇ HTTP (sync)
      ‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
      ‚îÇ                  ‚ñº
      ‚îÇ           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
      ‚îÇ           ‚îÇ    Fraud    ‚îÇ
      ‚îÇ           ‚îÇ   Service   ‚îÇ
      ‚îÇ           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
      ‚îÇ
      ‚îÇ Events (async)
      ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Analytics  ‚îÇ
‚îÇ   Service   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Key Points:
- Synchronous for user-facing critical path
- Asynchronous for notifications and analytics
- Services communicate via interfaces/events
- No shared databases
- Each service independently deployable
```

TESTING LOOSE COUPLING:

1. Unit Tests:
   ```go
   // Mock dependencies via interfaces
   mock := &MockFraudChecker{shouldApprove: true}
   service := PaymentService{fraudChecker: mock}
   service.ProcessPayment(100)
   ```

2. Integration Tests:
   ```go
   // Test actual service communication
   // Use test containers for dependencies
   testRedis := startTestRedis()
   testDB := startTestDB()
   service := NewPaymentService(testDB, testRedis)
   ```

3. Contract Tests:
   ```go
   // Verify API contracts between services
   // Provider: Payment Service
   // Consumer: Notification Service
   // Ensure contract not broken
   ```

NEXT STEPS:
- Review all chapters comprehensively
- Practice implementing patterns
- Build a complete microservices application
- Focus on observability and monitoring
- Learn about service mesh (Istio, Linkerd)

================================================================================
                    END OF CHAPTER 8 TEST RESULTS
================================================================================
